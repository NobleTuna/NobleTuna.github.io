{"meta":{"title":"Tuna's Room","subtitle":null,"description":null,"author":"NobleTuna","url":"http://NobleTuna.github.io","root":"/"},"pages":[{"title":"Who is Tuna?","date":"2019-06-28T11:30:17.000Z","updated":"2019-06-30T10:26:00.693Z","comments":true,"path":"about/index.html","permalink":"http://NobleTuna.github.io/about/index.html","excerpt":"","text":"여행과 기타를 좋아하는 풋내기 개발자(예정)입니다."}],"posts":[{"title":"v-for 에서 이벤트 처리","slug":"vue1","date":"2019-07-20T03:46:29.000Z","updated":"2019-07-20T04:35:00.305Z","comments":true,"path":"2019/07/20/vue1/","link":"","permalink":"http://NobleTuna.github.io/2019/07/20/vue1/","excerpt":"","text":"웹 프로젝트 중 헤더부분 아이콘배치를 v-for문을 이용해서 반복문 처리하려는데 이벤트 처리부분이 문제가 됬다. 1234567&lt;v-btn v-for=&quot;btnItem in btnItems&quot; icon :title=&quot;btnItem.title&quot; :key=&quot;btnItem.title&quot;&gt; &lt;v-icon @click=&quot;btnItem.clickAction&quot;&gt; &lt;/v-icon&gt;&lt;/v-btn&gt; 반복문 안에서 각 버튼별로 @click=&quot;btnItem.clickAction&quot; 에 다른 메소드를 실행시켜야 되는데 데이터 안에 메소드가 들어가 있는 것을 본적이 없었다. 될것같은데 안되네? 하면서 구글링하니 해결책이 쉽게 나오지않았다. 생각보다 시간이 걸렸는데 해놓고 보니 역시 들인 시간에 비해 간단했다. 1234567891011121314151617181920212223242526export default &#123; data() &#123; return &#123; btnItems: [ &#123; title: &quot;Bookmark&quot;, clickAction: () =&gt; &#123; this.favorite(); &#125;, icon: &quot;bookmark&quot; &#125;, &#123; title: &quot;translate&quot;, clickAction: () =&gt; &#123; this.trans(); &#125;, icon: &quot;g_translate&quot; &#125; ] &#125;; &#125;, methods:&#123; favorite()&#123;&#125;, trans()&#123;&#125; &#125;&#125; function() 을 사용하면 함수 안에 this가 가리키는게 뷰가 되므로 에로우 펑션을 쓰던지 함수 밖에서 this를 다른 변수에 선언하고 사용해야된다. 에로우 펑션이 익숙하지 않아서인지 지금봐도clickAction: () =&gt; { this.favorite(); } 부분은 어색하다. 이 방식으로 라우터 이동도 메서드로 내려서 이벤트를 모두 반복으로 처리할수 있었다.","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"Vue.js","slug":"Development/Vue-js","permalink":"http://NobleTuna.github.io/categories/Development/Vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://NobleTuna.github.io/tags/vue-js/"}]},{"title":"Firebase 'auth/account-exists-with-different-credential' 에러 처리","slug":"firebase1","date":"2019-07-15T11:35:58.000Z","updated":"2019-07-15T22:59:38.591Z","comments":true,"path":"2019/07/15/firebase1/","link":"","permalink":"http://NobleTuna.github.io/2019/07/15/firebase1/","excerpt":"","text":"웹 프로젝트를 진행하면서 Firebase로 서버를 구현중에 로그인 중복처리 문제가 있었다. 구글계정으로 회원가입이 되어있는데 같은 이메일 주소의 페이스북으로 가입하려면 auth/account-exists-with-different-credential 에러가 발생한다. 당연한 에러긴 한데 Firebase 완전한 해결 메서드를 제공하지 않아서 linkWithCredential메서드를 이용해 처리해야한다. 구글링을 해서 어찌어찌 해결되나 싶더니 팝업관련 에러가 난다. 페이스북 로그인창에서 또 팝업창을 요청하니 브라우져에서 막아 발생하는 에러였다. Firebase 에서 Redirect 방식의 로그인처리를 지원해주었기 때문에 이걸로 해결했다. 필요시 사용자에게 계정 연결 안내 메시지를 띄워주면 되겠다. Swal.fire는 SweetAlert2 라는 alert를 예쁘게 해주는 외부 라이브러리니 신경쓰지 않아도 된다. 1234567891011121314151617181920212223242526272829303132loginWithFacebook() &#123; var provider = new firebase.auth.FacebookAuthProvider(); return firebase.auth().signInWithPopup(provider).then(function(result) &#123; let accessToken = result.credential.accessToken let user = result.user return result &#125;).catch(function(error) &#123; if (error.code === &apos;auth/account-exists-with-different-credential&apos;) &#123; firebase.auth().fetchSignInMethodsForEmail(error.email).then(function(providers) &#123; if (providers[0] == &apos;google.com&apos;) &#123; var provider = new firebase.auth.GoogleAuthProvider(); // popup 에러때문에 리디렉 signInWithRedirect firebase.auth().signInWithRedirect(provider).then(function(result) &#123; firebase.auth().signInWithCredential(result.credential).then(user =&gt; &#123; user.linkWithCredential(error.credential) &#125;).catch(function(e) &#123; &#125;) &#125;).catch(function(e) &#123; &#125;) &#125; &#125;) &#125; else &#123; Swal.fire(&#123; title: &apos;Error!&apos;, text: &apos;예기치 않은 문제가 발생했습니다. 관리자에게 문의바랍니다. ErrorCode : &apos; + error.code, type: &apos;error&apos;, confirmButtonText: &apos;Ok!&apos; &#125;) &#125; &#125;) &#125;","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"Firebase","slug":"Development/Firebase","permalink":"http://NobleTuna.github.io/categories/Development/Firebase/"}],"tags":[{"name":"firebase","slug":"firebase","permalink":"http://NobleTuna.github.io/tags/firebase/"}]},{"title":"미디어 쿼리 삽질 일기","slug":"mediaqueryDiary","date":"2019-07-07T06:55:00.000Z","updated":"2019-07-07T22:44:26.260Z","comments":true,"path":"2019/07/07/mediaqueryDiary/","link":"","permalink":"http://NobleTuna.github.io/2019/07/07/mediaqueryDiary/","excerpt":"","text":"Vue.js로 싱글페이지 프로젝트를 진행중 반응형 페이지를 만들어야 한다는 요구사항이 있었다. 일단 당장 생각대로 스크립트에서 장치명이나 너비를 가져와 그에 따른 스타일을 적용시키면 되겠지 하고 구글링을 해서 스크립트를 짰다. 화면을 줄여보며 만족해하고 있을때 미디어쿼리라는것을 알았다. 생각해보니 반응형 웹페이지 나온지가 언젠인데 이런 무식한 스크립트로 하고있을 리가 없었다. 더러운 스크립트 싹 지우고 스타일에서 미디어쿼리로 작성하다보니 Vue에도 뭔가 있지 않을까 해서 찾아보았다. 아니나 다를까 Vue-mq 라는 플러그인도 있었고 vuetify에서 뷰포트에 따라 조건을 지정해둔 Display 속성도 있었다.. 템플릿 본문보다 길었던 반응형 스크립트가 hidden-sm-and-down 하나로 끝났다. 억울 포스트 작성하다보니 미디어쿼리를 보다 문득 궁금해져 CSS단에서 조건처리가 되나 해서 찾아보다 SASS 라는 것을 찾았다. CSS의 확장판인데 변수와 조건문까지도 지원을 하는 스타일언어였다. 그냥 이런게 있구나 하고 넘어간다.","categories":[{"name":"Diary","slug":"Diary","permalink":"http://NobleTuna.github.io/categories/Diary/"}],"tags":[{"name":"잡담","slug":"잡담","permalink":"http://NobleTuna.github.io/tags/잡담/"},{"name":"vue.js","slug":"vue-js","permalink":"http://NobleTuna.github.io/tags/vue-js/"}]},{"title":"Git 원격 저장소 여러개 연결하기","slug":"git1","date":"2019-07-02T12:32:29.000Z","updated":"2019-07-02T15:07:53.088Z","comments":true,"path":"2019/07/02/git1/","link":"","permalink":"http://NobleTuna.github.io/2019/07/02/git1/","excerpt":"","text":"Git 원격 저장소 여러개 연결하기원격저장소를 한개씩만 써봤는데 깃랩과 깃허브 두개를 연동할 일이 생겨서 구글링하고 정리했다. git remote add &quot;저장소명&quot; &quot;url&quot; 형태로 add 만 붙여주면 됬다 깃허브에서 로컬로 클론해온 후 깃랩과 연동하는 과정을 나열해보면 git clone https://github.com/NobleTuna/example.git깃허브에서 로컬로 클론, 이 경우 저장소 명은 origin 이 된다 cd example프로젝트 폴더로 이동 git remote add gitLab https://lab.tmp.com/NobleTuna/example.git깃랩에 생성해둔 example 저장소를 gitLab 으로 명시하고 연결 git remote -v원격 저장소 목록을 확인하는 명령어 1234gitLab https://lab.tmp.com/NobleTuna/example.git(fetch)gitLab https://lab.tmp.com/NobleTuna/example.git(push)origin https://github.com/NobleTuna/example.git(fetch)origin https://github.com/NobleTuna/example.git(push) 명시하지 않은 저장소 origin 과 명시하고 추가한 gitLab 저장소 확인 가능 이후 push 나 pull 할 경우 각각 저장소를 명시하면 된다. git pull origin masterorigin(깃허브)에서 pull git push gitLab mastergitLab(깃랩)으로 push 반대의 경우도 같다. push를 하기위에 두번씩 치기 귀찮을 경우 stackoverflow를 참고 추가로 원격저장소 주소를 변경하는 경우git remote set-url &quot;저장소명&quot; &quot;새로운URL&quot; 원격저장소 명시한 이름을 변경하는 경우git remote rename &quot;현재저장소명&quot; &quot;새로운저장소명&quot;","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"etc.","slug":"Development/etc","permalink":"http://NobleTuna.github.io/categories/Development/etc/"}],"tags":[{"name":"git","slug":"git","permalink":"http://NobleTuna.github.io/tags/git/"}]},{"title":"hexo README.md 추가하기","slug":"hexo2","date":"2019-06-30T10:29:38.000Z","updated":"2019-06-30T12:57:04.649Z","comments":true,"path":"2019/06/30/hexo2/","link":"","permalink":"http://NobleTuna.github.io/2019/06/30/hexo2/","excerpt":"","text":"Hexo README.md 파일 추가하기깃에 블로그에 대한 README 파일을 남기고 싶었다. 처음엔 단순히 public 폴더안에 README.md 파일을 만들고 deploy 하면 되겠지 했는데 핵소에선 public 폴더안 생성물은 generate 때마다 source폴더 내용물을 기반으로 갱신되면서 README파일이 삭제되는 문제가 있었다. 그렇다고 source폴더에 README.md를 만들면 generate 할때 html로 렌더링해버린다. 찾아보니 다행이 _config.yml에 랜더링을 제외하는 설정이 있었다. _config.yml 에 skip_render: README.md를 추가해주고 source폴더에 README.md 파일을 넣는것으로 해결되었다.","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"Hexo","slug":"Development/Hexo","permalink":"http://NobleTuna.github.io/categories/Development/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://NobleTuna.github.io/tags/hexo/"}]},{"title":"이더리움 도메인 공부","slug":"ethereum-domain","date":"2019-06-29T08:53:37.000Z","updated":"2019-06-29T09:47:33.780Z","comments":true,"path":"2019/06/29/ethereum-domain/","link":"","permalink":"http://NobleTuna.github.io/2019/06/29/ethereum-domain/","excerpt":"","text":"앞 포스팅들과 마찬가지로 난잡하다. 이더리움분산 어플리케이션(스마트 컨트랙트)을 탑재한 블록체인 2.0 분산화된 상태전이 머신 트랜잭션에 기반한 상태 전이단, 이전 상태로 되돌아 갈 수 없음 암호화 알고리즘을 활용 -&gt; 무작위로 상태전이가 일어나는 것을 방지 모든 참여자가 동일한 상태를 공유 블록은 해당 시점의 이더리움 상태를 나타낸다고 볼 수 있음 현재 블록 -&gt; 현재 이더리움의 상태 최초 상태 : Genesis Block 이더리움 계정의 종류외부 소유 계정(External Owned Account) ETH 잔액 유지 개인 키를 통한 주소 관리 ETH 전송, 컨트랙트 실행을 위한 거래 전송 가능 컨트랙트 코드를 가지고 있지 않음 (빈 문자열 hash 값) 컨트랙트 계정(CA Contract Account) ETH 잔액 유지 주소를 가지고 있으나 개인키는 존재하지 않음 컨트랙트 코드를 보유 거래나 메시지를 수신하면 보유하고 있는 컨트랙트 코드를 실행 이더리움의 상태전이 (State Transition) 블록 채굴로 인한 거래 내역 추가 시 상태전이 발생 상태전이함수에 의해 수행 트랜잭션 종류 (외부) 트랜잭션 : 외부 소유계정에서 외부소유 계정, 외부 소유계정에서 스마트컨트랙트 까지의 트랜잭션EOA가 다른 EOA 혹은 CA로 보내는 ‘서명된 메시지’블록체인에 저장됨출발지가 EOA 내부 트랜잭션 : 스마트컨트랙트 내부에서 진행되는 트랜잭션CA가 다른 CA 혹은 EOA에게 전달되는 ‘서명되지 않은 메시지’주로 컨트랙트 함수 호출에 사용블록체인에 별도 저장되지않음출발지가 CA 블록이더리움 장부에 기록되는 데이터의 기본 단위트랜잭션들의 집합 엉클 블록동일한 시점에 채굴된 블록 중 채굴 난이도가 낮아 메인 체인에 연결되지 못한 블록이더리움은 엉클 블록채굴도 보상을 줌블록생성 시간이 빠를 수록 엉클 블록의 발생 확률이 높음 문제점엉클블록에 포함된 트랜잭션은 승인되지 않았기 때문에 트랜잭션 처리 지연 발생승인되지 않은 블록에 연산이 소모되어 연산량이 낭비됨평균 블록생성 시간이 늘어나 채굴 난이도가 감소하게 되어 네트워크의 보안 수준이 낮아짐 작업증명(PoW, Proof of Work)이더리움 -&gt; Ethash 채굴이 전문 채굴기에 몰리는것을 막기위한 이더리움의 작업증명 계산은 어렵게, 검증은 쉽게 지분증명(PoS, Proof of Stake)검증자가 가진 지분에 비례한 확률로 블록 생성 권한을 획득하고 생성된 블록을 원하는 체인에 연결, 보상 획득PoW의 문제점을 개선 전력 소모량, 채굴 중앙화 등이더리움은 Casper를 통해 PoW로 전환중 Casper FFG(Friendly Finality Gadget)PoW + PoS 하이브리드 방식PoW 100개 블록마다 PoS 스마트 컨트랙트 개발 언어 Solidity : 현재 가장 많이 사용되고 있는 이더리움 스마트 컨트랙트 언어 하이퍼래저 패브릭이 여러 언어를 쓸 수 있는 이유 : 패쇄형 블록체인이라 언어가 다름에 따라 발생하는 과부화 위험이 적음 가스이더리움을 움직이게 하는 ‘기본 단위’트랜잭션, 스마트 컨트랙트를 위한 수수료스마트컨트랙트를 배포하거나 run할때 사용되는 수수료채굴자는 가스가격이 높은것부터 스마트 컨트랙트를 수행시킴가스 단위가 클 수록 트랜잭션의 빠른 처리 가능 각 동작마다 정해진 가스 비용이 있고 배포자가 정한 임의의 가스 리밋이 있음스마트 컨트랙트가 수행중에 가스비용이 리밋을 초과하게 되면 롤백됨 가스 수수료를 통한 채굴자의 유입유도 개발자의 간결한 코드 유도 악의적인 스마트 컨트랙트의 반복을 막기 위한 시스템 EVM (Ethereum virtual Machine)이더리움 스마트 컨트랙트를 실행하기 위한 가상머신 특징 튜링 완전머신, 스택 기반 구조, 32 Byte의 메모리 이더리움 주소 연산(160bit), 256 bit 암호화 알고리즘 등 이더리움 관련 구조 연산에 최적화 모든 동작을 수행하기 위해서는 사전에 가스가 지불되어야 함-&gt; DoS(Denial of Service)공격을 방지하기 위함 EVM의 프로그램은 내부에서만 실행되고 가상머신의 HOST 환경에는 접근 불가EVM간 메시지를 통해 데이터를 송수신할 수 있음결정적 머신 -&gt; 때문에 항상 동일한 상태를 반환 EVM Memory스마트 컨트랙트 호출 시 생성일반적인 PC의 RAM과 마찬가지로 휘발성Memory의 크기가 증가 시 가스가 반드시 소모되며 가스량은 지수적으로 증가사용자 정의 함수 내부 선언된 변수 EVM Storagekey-value 저장소key : 256qllxm, Value : 256비트스마트 컨트랙트는 자신의 storage에만 접근 가능스마트 컨트랙트에서 사용자 정의 함수 외부에 선언된 변수를 나타냄 Solidity이더리움 스마트 컨트랙트 언어의 종류가장 많이 활용되는 언어Java와 유사한 문법 객체지향 언어Class = Contract (유사)정적 타입 언어","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"BlockChain","slug":"Development/BlockChain","permalink":"http://NobleTuna.github.io/categories/Development/BlockChain/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://NobleTuna.github.io/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"http://NobleTuna.github.io/tags/ethereum/"}]},{"title":"블록체인 도메인 공부","slug":"blockchain-domain","date":"2019-06-29T04:42:31.000Z","updated":"2019-06-29T05:31:30.923Z","comments":true,"path":"2019/06/29/blockchain-domain/","link":"","permalink":"http://NobleTuna.github.io/2019/06/29/blockchain-domain/","excerpt":"","text":"빅데이터 도메인 포스팅과 마찬가지로 수업내용을 받아적은거라 난잡하다. 블록체인 The trust machine 신뢰를 만들어 주는 기술컴퓨터의 집단지성을 활용하여 서로 신뢰 할 수 없는 환경에서 사람들이 중립적이고 중앙화된 인증기관 없이 신뢰를 보장하는 기술 블록체인의 가치1975년 PC 등장 - 정보의 소유와 생산 - 다양한 지식에 대한 갈망1993년 인터넷 등장 - 정보의 공유 - 정보의 홍수2009년 블록체인 - 정보 신뢰 - 제 2의 인터넷 시대를 열 것이다 기술적 배경P2P 네트워크를 이용하여 거래 내역을 분산, 온라인 네트워크 참가자 모두에게 내용을 공개 및 기록새로운 거래가 일어날 때마다 노드들(참가자)이 가진 블록체인을 업데이트, 무결성을 유지하도록 하는 분산형 거래 시스템 ex) 기존의 은행등의 거래장부는 중앙 시스템에서 관리-&gt; 고객 모두가 장부를 가지고 있고 거래가 갱신될때마다 모든 장부를 갱신일정 간격으로 모든 장부를 비교해서 옳은 장부를 확인함(비트코인의 경우 10분) 프라이빗 블록체인허가된 노드만 참여할 수 있는 블록체인기업같은 곳에서 정보노출을 꺼리는 경우 사용 블록체인 핵심 기술 P2P 네트워크 (P2P Network) 암호화 (Encryption) : 주로 해쉬 (결과를 보고 입력을 예측하기 힘들다) 파일매니저 (File Manager), 블록화 :(비트코인의 경우) 10분간격으로 트랜젝션처리를 해서 장부로 블록을 만들고 그 내역을 해쉬함수로 암호화 해서 다음 블록이 가지고 있음체인처럼 이어져 중간에 위변조할 수 없다 합의 알고리즘 (Consensus Algorithm) 스마트 컨트랙트 ( Smart Contract) : 이더리움에 추가된 기능블록체인에 프로그램(코드)도 저장해 수행될 수 있도록 하는 기술블록체인 안에 들어감으로써 위변조 할 수 없는 계약이 됨 암호화폐기존에는 국가단위로 화폐발행을 했지만 이제는 기업도 화폐발행을 하기 시작함 (경제 민주화)예전 버스 토큰을 생각하면 거래속도등에서 대체화폐의 경제성과 가능성은 충분함 암호화폐에 대한 나라별 입장이 다름 비즈니스 도메인 활성화 코인SNS 스팀잇(steem it)게시물을 올리면 환전 가능한 암호화 화폐를 주는 SNS 블록체인 기술기반으로 만든 블로그 스팀잇 좋아요 같은 upvote 시스템 본인의 콘텐츠의 많은 공감과 댓글을 달게 되면 스팀파워는 올라가고, 대가로 스팀 달러의 보상 Cloud Filecone콘텐츠 (데이터)를 탈중앙화 시키고 인센티브를 통해 네트워크가 운영되는 클라우드 스토리지 서비스 위치 중심적으로 운영 되는 웹을 콘텐츠 중심으로 클라우드 저장소의 중앙화 문제 해결 인센티브를 통한 탈중앙화 클라우드 스토리지 서비스 IoTA사물인터넷과 블록체인을 융합한 새로운 플랫폼 (M2M Payment) IoT 기기 및 데이터 관리를 위한 블록체인 플랫폼으로 자체 개발한 블록체인 Tangle을 기반으로 하는 플랫폼 기존 비트코인 블록체인의 비효율성 (트랜젝션 처리건수, 모바일 기기 확장성), 및 수수료 문제 개선 디지털 금융의 미래 모든것이 디지털화 될 수는 없다. 그러나 디지털화 할 수 있는 모든것은 디지털화 될 것이다. - 헤르만 지몬 교수 비금융 분야인증/관리 전자 문서 관리 인증 권한 관리 디지털 신분증 자산거래 부동산 거래 시장 다이아몬드 인증/거래 금/은 거래 기타 예측 시장 온라인 투표 개인 의료 정보 IoT 디지털 콘텐츠 소유권 스마트 도어락(Slock it)에어비앤비의 응용편 Slock이 설치된 방에서 숙박을 원하는 여행자가 사용기간을 설정 후 비용을 지불하면 스마트 컨트렉트에 의해 해당 방에 설치된 도어락을 제어사용기간이 만료되면 스마트 컨트랙트에 의해 자동적으로 도어락에 대한 사용 권한을 반납이 모든 과정은 이더리움 블록체인에 의해 제어되면서 거래내역, 사용내역 등 데이터 무결성 보장, 신뢰된 서비스를 제공 냉동차 유통 고신뢰 서비스 기술식품 유통중 온도, 데이터등의 기록을 블록체인에 기록 의료 정보의 고신뢰 서비스 기술 (딥마인드 헬스와 NHS 의 협력)정보 수집 과정에 블록체인 기술을 도입함으로 데이터가 언제, 어떤 목적으로 사용됐는지에 대한 기록을 블록체인 상에 저장 응용) 발전소 오염물질 배출상황, 센서 점검한 사람등을 같이 기록해서 환경단체 제공 블록체인과 공유경제 사회공유 경제 : 한번 생산된 제품을 여럿이 공유해 쓰는 ‘협업소비’ 근간의 경제 방식공유에 의해 재화나 서비스, 데이터 교환이 이뤄지는 시스템 공유경제에서 발생하는 모든 데이터를 블록체인 플랫폼상에 기록 및 공유하여 데이터의 무결성과 거래의 신뢰성을 제공블록체인 플랫폼을 통해 제 3자의 개입 없이 신뢰성 기반 P2P 직접 거래 가능 블록체인 통한 에너지 공유기존에는 개인이 생산한 태양열 에너지를 기업에서 구매이더리움 기반의 스마트 컨트랙트를 이용한 P2P 에너지 거래 서비스개인과 개인간의 직접적인 신뢰성 높은 에너지 거래 가능 블록체인 기반 ‘디지털 거래소’스위스 최대 증권 거래소 SIX 블록체인 기반 ‘디지털 거래소’ 구축 발표 현재 주식에 적용되는 거소가 같이 스위스 금융시장감독청(FINMA)을 통하여 규제를 받을 수 있도록 함으로써 현행 규제 안에서 운영할 수 있는 디지털 자산 거래소를 구축을 목표로 한다. 암호화폐 거래를 규제 안에서 제도화해서 자본시장으로 끌어들여 디지털 자산가치에 대한 새로운 패러다임을 연다. 모든 금융 혹은 비 금융 자산을 디지털 화 하여, 거래 생태계를 구축 한다. 이를 위해 주식, 채권, ETF 부터 시작하고 향후 비 금융 자산인 예술품 및 특수한 물리적 자산까지 확장 하는 것을 목표 Machine Commerce (사물 경제 시대)IoT, AI, 블록체인이 융합되 자동적인 경제활동ex ) 예측 사용량만큼의 전기 구입, 자율주행자동차의 자동화된 주유 등등","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"BlockChain","slug":"Development/BlockChain","permalink":"http://NobleTuna.github.io/categories/Development/BlockChain/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://NobleTuna.github.io/tags/blockchain/"}]},{"title":"빅데이터 도메인 공부","slug":"bigdata","date":"2019-06-24T22:09:31.000Z","updated":"2019-06-29T05:28:15.970Z","comments":true,"path":"2019/06/25/bigdata/","link":"","permalink":"http://NobleTuna.github.io/2019/06/25/bigdata/","excerpt":"","text":"수업내용을 내가 이해한대로 받아적은것이라 난잡하다어설프게 한글사이에 영어가 섞여있는건 강사님의 말을 내 뇌피유가 따라가지 못했기 때문관련 프로젝트 진행하기 전에 한번 훑으면 아이디어 등에 도움될듯 해서 남긴다 클러스터링(Clustering)데이터를 유사도에 의해서 K개의 그룹으로 나누는것추천 시스템에서 주로 사용 백화점 고객을 구매 상품에 따라서 클러스터링함 추천 시스템을 의해 고객의 과거 패턴을 이용해서 클러스터링 함 Gene 데이터를 유사도에 따라서 클러스터링 함 텍스트 문서들을 주제에 따라서 클러스터링 함 Facebook 에서 이미지들을 유사한 이미지들로 클러스터링을 함 Call center에서 고객과 통화한 내용을 텍스트로 변환 하여 그 내용에 나타나는 단어나 어휘구나 어휘 절을 추출하고 이를 이용하여 각각의 통화내역을 그룹으로 나누어서 회사에 걸러온 상담 내용을 카테고리 별로 나누어 보고 각 카테고리 별로 요약 정보를 만들어냄 클러스터링을 다 비교해가면서 하기엔 시간이 많이 소모되므로 대부분 근사치를 이용한 클러스터링을 사용한다. K-Means Clustering평균점을 계산하여 센터를 계속 찾은 후 (무게중심) 각 센터에 가까운 것들끼리 클러스터링, 반복클러스터링 변화가 없으면 멈춤처음에 랜덤하게 시작하는 파티션에 따라서 결과값이 다르기 때문에 여러번 시도하고 그중에 가장 좋은 것으로 결정 단점 클러스터링 사이즈가 잘 맞지 않음(?) 클러스터가 공 모양으로 나온다 outliers가 있을 경우 평균점 계산때문에 부정확한 결과가 나옴 -&gt; K-Medoids 알고리즘 간단하지만 실제로 사용하지 않음 Hierarchical Clustering (계층 구조)top-down(하향식), bottom-up(상향식) 방식 두가지가 있음보통 bottom-up 방식 사용 토너먼트 대진표처럼 가까운것끼리 묶어나감가장 가까운 클러스터 두개를 merge, 클러스터가 k개가 될때까지 반복어떤 distance function을 쓰냐에 따라서 다름 distance function(각 클러스터간의 거리를 무엇을 기준으로 비교할 것인가) single-link : 각각 클러스터링 안에 제일 가까운 데이터 거리를 비교하고 머지 complete-link : 각각 클러스터링 안에서 제일 먼 데이터를 비교하고 머지, 클러스터 크기는 작게나옴 average-link : 각 클러스터의 데이터끼리 1:1로 거리를 비교하고 평균을냄 mean-link : 섞어놓고 전체 모든 점들간 거리 평균을 계산함 controid-link : 클러스터링의 센터값과 거리가 제일 가까운것과 머지,센터는 보통 평균을 씀, 여러개이면 랜덤한것을 클러스터링, 중심은 그것들의 센터값으로 비교 단점 centroid-link 를 사용하면 k-means와 비슷하게됨 (동그랗게) single link를 사용하면 클러스터가 길쭉하게 나옴 디스턴스 펑션에 따라 아웃라이어를 포함하는 경우도 생김 속도가 느림(데이터 갯수에 세제곱에 비례함) 장점 k-means와 다르게 최대 거리조건을 주면 클러스터 개수를 지정하지 않아도 (카테고리 갯수를 몰라도 ) 결과를 알 수 있음 DBSCAN Clustering점 하나에서 같은 반지름으로 묶어지는놈들을 계속해서 mergeunvisited 한놈을 계속해서 진행하면서 merge. 약간 2차원 BFS같은 느낌반지름과 (eps) 최소 몇개이상 모여야 클러스터로 인정할 것인가에 따라서 결과가 다름 EM Algorithm Clustering모수에 대한 입력값(초기값)이 여러개가 나올것이고 그중에 확률적으로 제일 높은것을 선택정규분포(클러스터)를 수정해가면서 정확도를 올림생성모델 사용생성모델(Generative Model) : 레이블이 없는 데이터도 학습하여 분류하는 모델 likelihood : 가능도. 확률likelihood 가 제일 높은것으로 선택결과값을 가지고 입력값을 추측하는 느낌클러스터링마다 각 점마다 각 클러스터에 들어갈 확률을 수치화함(그만큼 다른것들보다 자원소모(메모리)같은게 더 요구됨) PLSI생성모델 사용몇개의 주제에 대해 클러스터링 해라-&gt; 각각의 단어마다 주제를 선택하고 주제에 대해 단어집에서 나올 확률을 보고 확률이 높은 단어 선정 (주제를 뽑을 확률) * (단어를 뽑을 확률) 우리가 이런식으로 글을 쓴다는 모델모든 단어를 카운트하면 너무 커지니까 단어수에 제한을 두어 벡터화함EM Clustering과 마찬가지로 각 단어가 어떤 주제에 해당하는지 알 수 있음 Content based filtering methoditem 이나 product등과 같은 actual content를 이용함각 아이템간의 연관도를 이용해서 추천함 Collaborative filtering method각각의 유저는 비슷한 다른 유저와 동일하게 행동한다는 가정을 한 메소드누군가의 추천이 다른 유저들의 추천에 영향을 끼침User 가 직접 점수를 매긴 item들에 대한 rating 을 이용해서 추천다른 유저들의 의견을 이용함 유저의 평가, 샀다 안샀다 등의 유저 정보로유저의 평가를 보고 비슷한 평가군의 추천을 해줌memory based method : 평가내역등을 가지고 비슷하게 평가model based method : 과거의 레이팅으로 데이터로 구체적인 벡터(모델)을 만들어서 평가 (PLSI), matrix factorization Matrix Factorization(행렬 분해)곱해서 평점 매트릭스가 나오는 k개의 세로 유저행과 k개의 가로 영화수의 행렬을 구하고 곱해서 만든 행렬로 빈칸(평점을 매기지 않은 영화)를 추측할 수 있다. 학습을 통해 벡터를 내적했을때, 결과가 현재 가지고 있는 평점 데이터와 비슷한 벡터 두개(유저, 아이템)를 구함 곱하는 행렬이 여러개가 나올 수 있으니 정확하지 않을 수 있음-&gt; summary등 다른 텍스트 정보를 이용해 각각 벡터에 PLSI를 사용해 주제확률로 범위를 좁혀 좀더 정확한 행렬을 찾을 수 있음 단, 텍스트 정보가 연관성이 없을 경우 더 부정확한 결과가 나올 수 있으므로 PLSI를 먼저 확인하여 데이터 연관성, 노이즈 정도를 확인하고 사용해야한다","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"BigData","slug":"Development/BigData","permalink":"http://NobleTuna.github.io/categories/Development/BigData/"}],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"http://NobleTuna.github.io/tags/bigdata/"},{"name":"clustering","slug":"clustering","permalink":"http://NobleTuna.github.io/tags/clustering/"}]},{"title":"Hexo 명령어 기록","slug":"hexo1","date":"2019-06-23T14:05:56.000Z","updated":"2019-06-23T22:16:37.143Z","comments":true,"path":"2019/06/23/hexo1/","link":"","permalink":"http://NobleTuna.github.io/2019/06/23/hexo1/","excerpt":"","text":"Hexo 포스팅에 주로 쓰는 명령어들 정리초안 생성hexo new draft &quot;파일명&quot; 로컬에서 초안 확인hexo server --draft 초안파일을 post로 이동hexo publish &quot;파일명&quot; 글 수정이나 삭제시 디플로이 전에 실행hexo clean 파일 생성후 업로드 (generate deploy)hexo g -d 참고로 커맨드에서 복사는 컨트롤+Insert","categories":[{"name":"Development","slug":"Development","permalink":"http://NobleTuna.github.io/categories/Development/"},{"name":"Hexo","slug":"Development/Hexo","permalink":"http://NobleTuna.github.io/categories/Development/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://NobleTuna.github.io/tags/hexo/"}]},{"title":"첫 포스팅","slug":"firstPost","date":"2019-06-23T13:48:39.000Z","updated":"2019-06-23T22:14:53.570Z","comments":true,"path":"2019/06/23/firstPost/","link":"","permalink":"http://NobleTuna.github.io/2019/06/23/firstPost/","excerpt":"","text":"미뤄뒀던 블로그를 개설했다. 꾸준히 운영할지는 알수없음 로고랑 나머지는 다음에 하기로 하자","categories":[{"name":"Diary","slug":"Diary","permalink":"http://NobleTuna.github.io/categories/Diary/"}],"tags":[{"name":"잡담","slug":"잡담","permalink":"http://NobleTuna.github.io/tags/잡담/"}]}]}